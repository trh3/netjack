{
    "collab_server" : "",
    "contents" : "#' Network Manipulation Functions\n#'\n#'@name network_functions\n#'\nNULL\n\n\n\n#' Node level jackknife function\n#'\n#' Removes each node in turn from the Net, and returns a list of jackknifed Net objects\n#'\n#' @param Net Network to jackknife\n#'\n#' @return A list of Net objects\n#' @export\n#'\n#'@rdname network_functions\nnode_jackknife = function(Net){\n\n  toReturn = list()\n\n  for(i in 1:dim(Net@net)[[1]]){\n    toReturn[[i]] = methods::new(\"Net\", net = Net@net[-i,-i],\n                        net.name = Net@net.name,\n                        node.variables = lapply(Net@node.variables, function(x, i){\n                          return(x[-i])\n                        }, i = i))\n  }\n  names(toReturn) = as.character(1:dim(Net@net)[[1]])\n  return(toReturn)\n}\n\n#' Network level jackknife function\n#'\n#' Removes each subnetwork in turn from the Net, and returns a list of jackknifed Net objects\n#'\n#' @param network.variable character name of node variable containing network labels\n#' @return A list of Net objects\n#' @export\n#'\n#'@rdname network_functions\nnetwork_jackknife = function(Net, network.variable){\n\n  toReturn = list()\n\n  networks = unlist(Net@node.variables[network.variable])\n  uniNets = unique(names(table(networks)))\n  print(uniNets)\n  for(i in 1:length(uniNets)){\n    toReturn[[i]] = methods::new(\"Net\", net = Net@net[-which(networks == uniNets[i]),-which(networks == uniNets[i])],\n                        net.name = Net@net.name,\n                        node.variables = lapply(Net@node.variables, function(x, i){\n                          return(x[-i])\n                        }, i = which(networks == uniNets[i])))\n  }\n  names(toReturn) = as.character(uniNets)\n  return(toReturn)\n}\n\n\n#' Absolute Thresholding\n#'\n#' Applies an absolute thresholding to target network, returning a binary network.\n#'\n#' @param thresholds Vector of thresholds to use\n#'\n#' @return A list of Net objects, named at threshold level.\n#' @export\n#'\n#'@rdname network_functions\nabsolute_threshold = function(Net, thresholds){\n\n  toReturn = list()\n\n\n  toReturn = lapply(thresholds, function(x, network){\n    print(x)\n    temp = (Net@net > x)*1\n    return(methods::new(\"Net\", net = temp, net.name = Net@net.name, node.variables = Net@node.variables))\n  }, network = Net@net)\n  names(toReturn) = as.character(thresholds)\n  return(toReturn)\n}\n\n#' Relative Thresholding\n#'\n#' Applies a relative threshold based on target density to target network\n#'\n#' @param percentiles Vector of densities to threshold at\n#'\n#' @return List of net objects with named at the density threshold.\n#' @export\n#'\n#' @rdname network_functions\nrelative_threshold = function(Net, percentiles){\n\n  toReturn = list()\n  toggle = isSymmetric(Net@net)\n  tempOrg = Net@net\n  diag(tempOrg) = NA\n  toReturn = lapply(percentiles, function(x, network){\n    if(toggle){\n    target = stats::quantile(as.numeric(network[upper.tri(network)]), probs = x)\n    }else{\n      target = stats::quantile(as.numeric(network), probs = x, na.rm = T)\n    }\n    temp = (network > target)*1\n    return(methods::new(\"Net\", net = temp, net.name = Net@net.name, node.variables = Net@node.variables))\n  }, network = tempOrg)\n  names(toReturn) = as.character(percentiles)\n  return(toReturn)\n}\n\n\n",
    "created" : 1526666933112.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2826934126",
    "id" : "84A95D60",
    "lastKnownWriteTime" : 1526668668,
    "last_content_update" : 1526668668766,
    "path" : "E:/Dropbox/netjack/R/network_functions.R",
    "project_path" : "R/network_functions.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}