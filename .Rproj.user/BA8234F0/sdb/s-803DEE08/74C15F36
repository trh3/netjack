{
    "collab_server" : "",
    "contents" : "\n#' Constructor for single Net object\n#'\n#' This function takes a single network, as an adjacency matrix, and returns a\n#' Net object.\n#'\n#' @param matrix Network represented as an adjacency matrix\n#' @param net.name Name of the network (optional)\n#' @param node.variables Node level variables (optional)\n#'\n#' @return A Net instance\n#' @export\n#'\nas_Net <- function(matrix, net.name, node.variables){\n  if(missing(node.variables)){\n    node.variables = list(index = 1:dim(matrix)[[1]])\n  }else{\n    if(class(node.variables) == \"data.frame\"){\n      node.variables = as.list(node.variables)\n    }\n    node.variables = c(list(index = 1:dim(matrix)[[1]]), node.variables)\n  }\n  if(missing(net.name)){\n    net.name = \"\"\n  }\n  return(methods::new(\"Net\", net =matrix, net.name=net.name, node.variables = node.variables))\n}\n\n#' Constructor for a NetSample object\n#'\n#' This function takes a list of adjacency matrices, and returns a NetSample\n#' object.\n#'\n#' @param matrixList A list of adjacency matrices\n#' @param net.names A character vector of network names\n#' @param node.variables A list of node level variables to be associated with\n#'   every network in the sample.\n#' @param sample.variables A list of network level variables.\n#'\n#' @return A NetSample instance.\n#' @export\n#'\nas_NetSample <- function(matrixList, net.names, node.variables, sample.variables){\n  temp = list()\n  if(missing(sample.variables)){\n    sample.variables = list()\n  }\n  if(class(sample.variables) == \"data.frame\"){\n    sample.variables = as.list(sample.variables)\n  }\n    sample.variables$orig.net = net.names\n  for(i in 1:length(matrixList)){\n    temp[[i]] = as.Net(matrixList[[i]], net.names[i], node.variables)\n  }\n  toReturn = methods::new(\"NetSample\", nets = temp, net.names = net.names, sample.variables = sample.variables)\n  return(toReturn)\n}\n\n#' Apply a network manipulation function to a single network, or to a sample of\n#' networks\n#'\n#' This function applies a network manipulation function to a single network or\n#' sample of networks, and returns a NetSet, or NetSampleSet containing the\n#' results.\n#'\n#' @param network An Net object or a NetSample object\n#' @param net.function A network manipulation function (reference or character)\n#' @param net.function.args A labeled list containing arguments to the\n#'   net.function\n#' @param orig.net.name The original network name, when applying net_apply to a\n#'   Net\n#'\n#' @return A NetSet or NetSampleSet object\n#' @export\n#'\nsetGeneric(\"net_apply\", function(network, net.function, net.function.args, orig.net.name) {\n  standardGeneric(\"net_apply\")\n})\n\n\n#' @describeIn net_apply net_apply for Net\nsetMethod(\"net_apply\", signature = c(network = \"Net\", net.function = \"ANY\",\n                                     net.function.args = \"ANY\",\n                                     orig.net.name = \"ANY\"),\n          function(network, net.function, net.function.args, orig.net.name){\n            net.function.true = match.fun(net.function)\n            if(missing(net.function.args)){\n              net.function.args = list()\n              results = do.call(net.function.true, list(network))\n            }else{\n              results = do.call(net.function.true, c(list(network), net.function.args))\n            }\n            if(missing(orig.net.name)){\n              orig.net.name = deparse(substitute(network))\n            }\n\n            toReturn = methods::new(\"NetSet\",fun.name = deparse(substitute(net.function)),\n                           fun = net.function.true,\n                           fun.args = net.function.args,\n                           orig.net = network,\n                           orig.net.name = orig.net.name,\n                           nets = results,\n                           nets.names = names(results),\n                           iter = FALSE)\n            return(toReturn)\n          })\n\n\n#' @describeIn net_apply net_apply for NetSample\nsetMethod(\"net_apply\", signature = c(network = \"NetSample\", net.function = \"ANY\",\n                                     net.function.args = \"ANY\",\n                                     orig.net.name = \"missing\"),\n          function(network, net.function, net.function.args, orig.net.name){\n            if(missing(net.function.args)){\n              net.function.args = list()\n            }\n            net.function.true = match.fun(net.function)\n            results = mapply(FUN = function(x, name){\n              return(net_apply(x, net.function = net.function, net.function.args = net.function.args,\n                               orig.net.name = name))\n              },\n              network@nets, network@net.names)\n\n            toReturn = methods::new(\"NetSampleSet\",\n                           fun.name = deparse(substitute(net.function)),\n                           fun = net.function.true,\n                           fun.args = net.function.args,\n                           net.sets = results,\n                           net.names = network@net.names,\n                           sample.variables = network@sample.variables)\n\n            return(toReturn)\n          })\n\n#'Apply a network statistic function to a NetSet or NetSampleSet object.\n#'\n#'This function applies a network statistic function to a NetSet or NetSampleSet\n#'object, and returns the calculated network statistics.\n#'\n#'@param netSet A NetSet or NetSampleSet object.\n#'@param net.stat.fun The network statistic function\n#'@param net.stat.fun.args A list of additional arguments to the network\n#'  statistic function\n#'@param net.stat.name A descriptive name for the network statistic (defaults to\n#'  deparsed name of statistic function)\n#'\n#'@return A NetStatSet or NetSampleStatSet\n#'@export\n#'\nsetGeneric(\"net_stat_apply\", function(netSet, net.stat.fun, net.stat.fun.args, net.stat.name) {\n  standardGeneric(\"net_stat_apply\")\n})\n\n#' @describeIn net_stat_apply net_stat_apply for NetSet\nsetMethod(\"net_stat_apply\", signature = c(netSet = \"NetSet\", net.stat.fun = \"ANY\",\n                                          net.stat.fun.args = \"ANY\", net.stat.name = \"ANY\"),\n          function(netSet, net.stat.fun, net.stat.fun.args, net.stat.name){\n            if(missing(net.stat.name)){\n              net.stat.name = deparse(substitute(net.stat.fun))\n            }\n            net.stat.fun = match.fun(net.stat.fun)\n            if(missing(net.stat.fun.args)){\n              net.stat.fun.args = list()\n            }\n            orig.stat = do.call(net.stat.fun, c(net.stat.fun.args, netSet@orig.net))\n            nets.stat = lapply(netSet@nets, function(x){\n              return(do.call(net.stat.fun, c(net.stat.fun.args, x)))\n            })\n            toReturn = methods::new(\"NetStatSet\",fun = netSet@fun,\n                           fun.name = netSet@fun.name,\n                           fun.args = netSet@fun.args,\n                           stat.fun = net.stat.fun,\n                           stat.fun.name = net.stat.name,\n                           stat.fun.args = net.stat.fun.args,\n                           orig.net.name = netSet@orig.net.name,\n                           orig.net.stat = orig.stat,\n                           nets.stat = nets.stat,\n                           nets.names = netSet@nets.names)\n            return(toReturn)\n          })\n\n\n#' @describeIn net_stat_apply Converter for NetSampleSet\nsetMethod(\"net_stat_apply\", signature = c(netSet = \"NetSampleSet\", net.stat.fun = \"ANY\",\n                                          net.stat.fun.args = \"ANY\", net.stat.name = \"ANY\"),\n          function(netSet, net.stat.fun, net.stat.fun.args, net.stat.name){\n             if(missing(net.stat.name)){\n              net.stat.name = deparse(substitute(net.stat.fun))\n            }\n            net.stat.fun.name = deparse(substitute(net.stat.fun))\n            net.stat.fun = match.fun(net.stat.fun)\n            if(missing(net.stat.fun.args)){\n              net.stat.fun.args = list()\n            }\n            nets.stat = lapply(netSet@net.sets, FUN = net_stat_apply, net.stat.fun = net.stat.fun,\n                               net.stat.fun.args = net.stat.fun.args, net.stat.name = net.stat.name)\n\n            toReturn = methods::new(\"NetSampleStatSet\",fun = netSet@fun,\n                           fun.name = netSet@fun.name,\n                           fun.args = netSet@fun.args,\n                           stat.fun = net.stat.fun,\n                           stat.fun.name = net.stat.name,\n                           stat.fun.args = net.stat.fun.args,\n                           nets.stat = nets.stat,\n                           net.names = netSet@net.names,\n                           sample.variables = netSet@sample.variables)\n            return(toReturn)\n          })\n\n#' Network statistics to long format dataframe\n#'\n#' This function converts a NetStatSet or NetSampleStatSet into a long format\n#' dataframe\n#' @param netStatSet A NetStatSet or NetSampleStatSet object\n#'\n#' @return A long format dataframe containing the name of the original network,\n#'   the original network network statistic, the name of the manipulated\n#'   network, the manipulated network network statistic and the name of the\n#'   network statistic.\n#' @export\n#'\nsetGeneric(\"to_data_frame\", function(netStatSet) {\n  standardGeneric(\"to_data_frame\")\n})\n\n#' @describeIn to_data_frame Converter for NetSampleStatSet\nsetMethod(\"to_data_frame\", signature = c(netStatSet = \"NetStatSet\"),\n          function(netStatSet){\n            toReturn = data.frame(orig.net = netStatSet@orig.net.name,\n                                  orig.stat = netStatSet@orig.net.stat,\n                                  net.names = netStatSet@nets.names,\n                                  nets.stat = as.numeric(netStatSet@nets.stat),\n                                  stat.name = netStatSet@stat.fun.name)\n            return(toReturn)\n          })\n\n#' @describeIn to_data_frame Converter for NetSampleStatSet\nsetMethod(\"to_data_frame\", signature = c(netStatSet = \"NetSampleStatSet\"),\n          function(netStatSet){\n            toReturn = lapply(netStatSet@nets.stat, to_data_frame)\n            toReturn = do.call(\"rbind\", toReturn)\n\n            if(length(netStatSet@sample.variables)> 0){\n              temp = as.data.frame(netStatSet@sample.variables)\n              toReturn = merge(toReturn, temp, by = \"orig.net\")\n            }\n            return(toReturn)\n          })\n\n\n#' Test for differences from original statistic\n#'\n#' This function tests for significant differences from the original network\n#' statistic as a result of the network manipulation. If non-parametric is\n#' chosen, this is done using the Wilcox test, otherwise, Welch's t-test.\n#'\n#' @param netSampleStatSet Input NetSampleStatSet\n#' @param p.adjust character string for requested multiple comparisons\n#'   adjustment. Defaults to Benjamani-Hochberg\n#' @param non.parametric Logical. if true, test is performed using Wilcox test.\n#'   If false, Welch's t-test. Defaults to false.\n#'\n#' @return A data frame containing original and adjusted p.values, as well as\n#'   differences, labeled with manipulation name.\n#' @export\n#'\ndiff_test = function(netSampleStatSet, p.adjust = \"BH\", non.parametric = F){\n\n  toPlot = to_data_frame(netSampleStatSet)\n\n  net.names = names(table(toPlot$net.names))\n\n  results = lapply(net.names,FUN = function(name, toPlot){\n    sub = toPlot[which(toPlot$net.names == name),]\n    subDiff = sub$nets.stat-sub$orig.stat\n\n    if(non.parametric){\n      diffTest = stats::wilcox.test(sub$nets.stats, sub$orig.stat, paired = T)\n    }else{\n      diffTest = stats::t.test(subDiff)\n    }\n    return(data.frame(net.names = name,diff = diffTest$estimate, p = diffTest$p.value))\n  }, toPlot = toPlot)\n\n  results <- as.data.frame(do.call(\"rbind\", results))\n  results$adjusted.p = stats::p.adjust(results$p, method = p.adjust)\n  return(results)\n}\n\n#' Group difference test\n#'\n#' This function implements the group difference test on a network statistic.\n#' This test assesses if the change in the network statistic due to the network\n#' manipulation is significantly different between groups.\n#'\n#' If the sample has 2 groups, this test is performed using Welch's t-test or\n#' Wilcox test. If the sample has 3 or more groups, the test is performed using\n#' a 1-way ANOVA, or Kruskal-Wallis test. Differences are tested at each network\n#' manipulation.\n#'\n#' @param netSampleStatSet Input NetSampleStatSet\n#' @param grouping.variable character name of sample level grouping variable\n#' @param p.adjust character string for requested multiple comparisons\n#'   adjustment. Defaults to Benjamani-Hochberg\n#' @param non.parametric Logical. if true, test is performed using Wilcox test.\n#'   If false, Welch's t-test. Defaults to false.\n#'\n#' @return A data frame containing original and adjusted p.values.\n#' @export\n#'\n group_diff_test = function(netSampleStatSet,grouping.variable, p.adjust = \"BY\", non.parametric = F){\n\n  toPlot = to_data_frame(netSampleStatSet)\n\n  net.names = names(table(toPlot$net.names))\n  form = paste0(\"subDiff\", \"~\", grouping.variable)\n  results = lapply(net.names,FUN = function(name, toPlot){\n    sub = toPlot[which(toPlot$net.names == name),]\n    sub$subDiff = sub$nets.stat-sub$orig.stat\n    form = stats::as.formula(form)\n    if(non.parametric){\n      groupTest <- stats::kruskal.test(form, toPlot = sub)\n      return(data.frame(net.names = name, p = groupTest$p.value))\n    }else{\n      groupTest <- stats::anova(stats::lm(form, toPlot = sub))\n      return(data.frame(net.names = name, p = groupTest$\"Pr(>F)\"[1]))\n    }\n  }, toPlot = toPlot)\n\n  results <- as.data.frame(do.call(\"rbind\", results))\n  results$adjusted.p = stats::p.adjust(results$p, method = p.adjust)\n  return(results)\n}\n\n #' Group test\n #'\n #' This function implements the group test on a network statistic. This test\n #' assesses if the network statistic is significantly different between groups,\n #' at each network manipulation.\n #'\n #' If the sample has 2 groups, this test is performed using Welch's t-test or\n #' Wilcox test. If the sample has 3 or more groups, the test is performed using\n #' a 1-way ANOVA, or Kruskal-Wallis test. Differences are tested at each\n #' network manipulation.\n #'\n #' @param netSampleStatSet Input NetSampleStatSet\n #' @param grouping.variable character name of sample level grouping variable\n #' @param p.adjust character string for requested multiple comparisons\n #'   adjustment. Defaults to Benjamani-Hochberg\n #' @param non.parametric Logical. if true, test is performed using Wilcox test.\n #'   If false, Welch's t-test. Defaults to false.\n #'\n #' @return A data frame containing original and adjusted p.values.\n #' @export\ngroup_test = function(netSampleStatSet, grouping.variable, p.adjust = \"BY\", non.parametric = F){\n  toPlot <- to_data_frame(netSampleStatSet)\n  form = paste0(\"nets.stat\", \"~\", grouping.variable)\n  form = stats::as.formula(form)\n  net.names = names(table(toPlot$net.names))\n  results = lapply(net.names,FUN = function(name, toPlot){\n\n    sub = toPlot[which(toPlot$net.names == name),]\n    if(non.parametric){\n      groupTest <- stats::kruskal.test(form, sub)\n      return(data.frame(net.names = name, p = groupTest$p.value))\n    }else{\n      groupTest <- stats::anova(stats::lm(form, toPlot = sub))\n      return(data.frame(net.names = name, p = groupTest$\"Pr(>F)\"[1]))\n    }\n  }, toPlot = toPlot)\n\n  results <- as.data.frame(do.call(\"rbind\", results))\n  results[\"adjusted.p\"] = stats::p.adjust(results$p, method = p.adjust)\n  return(results)\n}\n\n\n\n#' Difference Test Plots\n#'\n#' This function performs the difference test and generates a ggplot object representing the results.\n#'\n#' @inheritParams diff_test\n#' @param labels ggplot2 labs object. Labels for the plot\n#' @param sort one of \"alpha\", \"mean\", \"median\". \"alpha\" sorts in alpha numeric order, while mean and median sort by decreasing values.\n#' @param p.threshold Numeric. Threshold by which to highlight results. Defaults to .05\n#' @param hide.non.sig Logical. If true, non significant (as defined by p.threshold) are not plotted.\n#'\n#' @return A ggplot object\n#' @export\n#'\nnet_ggPlot = function(netSampleStatSet, labels, sort = \"alpha\", p.threshold = .05, p.adjust = \"BY\", hide.non.sig = F,non.parametric = F){\n\ntoPlot = to_data_frame(netSampleStatSet)\n  testtoPlot <- diff_test(netSampleStatSet, p.adjust = p.adjust, non.parametric = non.parametric)\n  toPlot = merge(toPlot, testtoPlot, by = \"net.names\")\n  toPlot$diff = toPlot$nets.stat - toPlot$orig.stat\n  if(sort == \"alpha\"){\n    if(!any(is.na(as.numeric(toPlot$net.names)))){\n        toPlot$net.names = factor(toPlot$net.names, level = sort(unique(as.numeric(levels(toPlot$net.names)[as.numeric(toPlot$net.names)]))))\n      }\n  }\n  if(sort == \"mean\"){\n    agg <- stats::aggregate(toPlot$diff, by = toPlot[\"net.names\"], mean, na.rm = T)\n    ord = order(agg$x)\n    toPlot$net.names = factor(toPlot$net.names, level = agg$net.names[ord])\n  }\n\n  if(sort == \"median\"){\n    agg <- stats::aggregate(toPlot$diff, by = toPlot[\"net.names\"], stats::median, na.rm = T)\n    ord = order(agg$x)\n    toPlot$net.names = factor(toPlot$net.names, level = agg$net.names[ord])\n  }\n\n  if(!hide.non.sig){\n    toPlot$p.thres = T\n  }else{\n    toPlot$p.thres = FALSE\n    toPlot$p.thres[which(toPlot$adjusted.p < p.threshold)] = TRUE\n  }\n\n  toPlot = ggplot2::ggplot(toPlot[toPlot$p.thres,], ggplot2::aes(x = as.factor(net.names), y = diff, color = (adjusted.p < p.threshold)))+\n    ggplot2::geom_boxplot() + ggplot2::coord_flip() + ggplot2::scale_color_manual(values = c(\"FALSE\" =\"black\", \"TRUE\" =\"red\"),name = \"Significant\\nDifferences\", labels = c(paste0(\"p > \", p.threshold),\n                                                                                                       paste0(\"p <\", p.threshold))) +ggplot2::theme_classic()\n\n  if(missing(labels)){\n    toPlot = toPlot+ ggplot2::labs(x = \"Change Name\", y = paste0(\"Difference from Original \", toPlot$stat.name))\n  }else{\n    toPlot = toPlot + labels\n  }\n  return(toPlot)\n\n}\n\n#' Group Test Plots\n#'\n#' This function performs the group test and generates a ggplot object representing the results.\n#'\n#' @inheritParams group_test\n#' @param labels ggplot2 labs object. Labels for the plot\n#' @param sort one of \"alpha\", \"mag\"; \"alpha\" sorts in alpha numeric order, while \"mag\" sorts in order of decreasing effect size\n#' @param p.threshold Numeric. Threshold by which to highlight results. Defaults to .05\n#' @param hide.non.sig Logical. If true, non significant (as defined by p.threshold) are not plotted.\n#'\n#' @return A ggplot object\n#' @export\n#'\nnetGroup_ggPlot = function(netSampleStatSet, grouping.variable, labels, sort = \"alpha\", p.threshold = .05, p.adjust = \"BY\", hide.non.sig = F, non.parametric = F){\n\n  toPlot = to_data_frame(netSampleStatSet)\n  testtoPlot <- group_test(netSampleStatSet,grouping.variable = grouping.variable, p.adjust = p.adjust, non.parametric = non.parametric)\n  toPlot = merge(toPlot, testtoPlot, by = \"net.names\")\n\n  if(sort == \"alpha\"){\n    if(!any(is.na(as.numeric(toPlot$net.names)))){\n        toPlot$net.names = factor(toPlot$net.names, level = sort(unique(as.numeric(levels(toPlot$net.names)[as.numeric(toPlot$net.names)]))))\n      }\n  }\n  if(sort == \"mag\"){\n    agg <- stats::aggregate(toPlot$adjusted.p, by = toPlot[\"net.names\"], mean, na.rm = T)\n    ord = order(agg$x, decreasing = T)\n    toPlot$net.names = factor(toPlot$net.names, level = agg$net.names[ord])\n  }\n\n  if(!hide.non.sig){\n    toPlot$p.thres = T\n  }else{\n    toPlot$p.thres = FALSE\n    toPlot$p.thres[which(toPlot$adjusted.p < p.threshold)] = TRUE\n  }\n  group = as.factor(toPlot[,grouping.variable])\n\n  toPlot = ggplot2::ggplot(toPlot[toPlot$p.thres,], ggplot2::aes(x = as.factor(net.names), y = nets.stat, color = (adjusted.p < p.threshold), fill = group))+\n    ggplot2::geom_boxplot() + ggplot2::coord_flip() + ggplot2::scale_color_manual(values = c(\"FALSE\" =\"black\", \"TRUE\" =\"red\"),name = \"Significant\\nDifferences\", labels = c(paste0(\"p > \", p.threshold),\n                                                                                                       paste0(\"p <\", p.threshold)))+\n    ggplot2::scale_fill_discrete(name = \"Group\")+ggplot2::theme_classic()\n\n  if(missing(labels)){\n    toPlot = toPlot+ ggplot2::labs(x = \"Change Name\", y = paste0(toPlot$stat.name))\n  }else{\n    toPlot = toPlot + labels\n  }\n  return(toPlot)\n}\n\n#' Group Difference Plots\n#'\n#' This function performs the group difference test and generates a ggplot object representing the results.\n#'\n#' @inheritParams group_diff_test\n#' @param labels ggplot2 labs object. Labels for the plot\n#' @param sort one of \"alpha\", \"mag\"; \"alpha\" sorts in alpha numeric order, while \"mag\" sorts in order of decreasing effect size\n#' @param p.threshold Numeric. Threshold by which to highlight results. Defaults to .05\n#' @param hide.non.sig Logical. If true, non significant (as defined by p.threshold) are not plotted.\n#'\n#' @return A ggplot object\n#' @export\nnetGroupDiff_ggPlot = function(netSampleStatSet, grouping.variable, labels, sort = \"alpha\", p.threshold = .05, p.adjust = \"BY\", hide.non.sig = F, non.parametric = F){\n\n  toPlot = to_data_frame(netSampleStatSet)\n  testtoPlot <- group_diff_test(netSampleStatSet,grouping.variable = grouping.variable, p.adjust = p.adjust, non.parametric = non.parametric)\n  toPlot = merge(toPlot, testtoPlot, by = \"net.names\")\n\n  if(sort == \"alpha\"){\n    if(!any(is.na(as.numeric(toPlot$net.names)))){\n      toPlot$net.names = factor(toPlot$net.names, level = sort(unique(as.numeric(levels(toPlot$net.names)[as.numeric(toPlot$net.names)]))))\n    }\n  }\n  if(sort == \"mag\"){\n    agg <- stats::aggregate(toPlot$adjusted.p, by = toPlot[\"net.names\"], mean, na.rm = T)\n    ord = order(agg$x, decreasing = T)\n    toPlot$net.names = factor(toPlot$net.names, level = agg$net.names[ord])\n  }\n\n  if(!hide.non.sig){\n    toPlot$p.thres = T\n  }else{\n    toPlot$p.thres = FALSE\n    toPlot$p.thres[which(toPlot$adjusted.p < p.threshold)] = TRUE\n  }\n  group = as.factor(toPlot[,grouping.variable])\n  toPlot$diff = toPlot$nets.stat - toPlot$orig.stat\n  toPlot = ggplot2::ggplot(toPlot[toPlot$p.thres,], ggplot2::aes(x = as.factor(net.names), y = diff, color = (adjusted.p < p.threshold), fill = group))+\n    ggplot2::geom_boxplot() + ggplot2::coord_flip() + ggplot2::scale_color_manual(values = c(\"FALSE\" =\"black\", \"TRUE\" =\"red\"),name = \"Significant\\nDifferences\", labels = c(paste0(\"p > \", p.threshold),\n                                                                                                                                                 paste0(\"p <\", p.threshold)))+\n    ggplot2::scale_fill_discrete(name = \"Group\")+ggplot2::theme_classic()\n\n  if(missing(labels)){\n    toPlot = toPlot+ ggplot2::labs(x = \"Change Name\", y = paste0(\"Difference from Original \", toPlot$stat.name))\n  }else{\n    toPlot = toPlot + labels\n  }\n  return(toPlot)\n}\n\n",
    "created" : 1526657163909.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3738919687",
    "id" : "74C15F36",
    "lastKnownWriteTime" : 1526669395,
    "last_content_update" : 1526669395732,
    "path" : "E:/Dropbox/netjack/R/net_apply.R",
    "project_path" : "R/net_apply.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}